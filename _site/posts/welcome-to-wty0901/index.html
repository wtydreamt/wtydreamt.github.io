<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/assets/images/log.ico" type="image/x-icon"><link rel="icon" href="your_ico.ico" type="image/x-icon"><title> memcache 资料!</title><meta name="description" content="MemCache是什么"><link rel="canonical" href="https://wtydreamt.github.io/posts/welcome-to-wty0901/"><link rel="alternate" type="application/rss+xml" title="TingYu Wang" href="https://wtydreamt.github.io/feed.xml"><link href='https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|Roboto+Condensed:700&subset=latin' rel='stylesheet' type='text/css'><link rel="stylesheet" href="https://wtydreamt.github.io/assets/css/main.css"><meta property="og:url" content="https://wtydreamt.github.io/posts/welcome-to-wty0901/"><meta property="og:type" content="website"><meta property="og:title" content="memcache 资料!"><meta property="og:description" content="入门到放弃！"><meta property="og:site_name" content="TingYu Wang"><meta name="twitter:card" content="summary"><meta name="twitter:url" content="https://wtydreamt.github.io/posts/welcome-to-wty0901/"><meta name="twitter:title" content="memcache 资料!"><meta name="twitter:description" content="入门到放弃！"><meta property="og:image" content="https://wtydreamt.github.io/assets/images/railss.jpg"><meta name="twitter:image" content="https://wtydreamt.github.io/assets/images/railss.jpg"><body><div id="shadow"></div><header class="main-header content-wrapper"> <input type="checkbox" id="menu-checkbox" /><nav class="center-wrapper nav-main"> <a class="blog-logo" href="/">首页</a> <a class="blog-logo" href="/posts">博客目录</a> <a class="blog-logo" href="/about">关于我</a> <label for="menu-checkbox" class="toggle-button" data-open="☰" data-close="☰" onclick></label></nav></header><aside class="sidebar" role="note" style="background-image: url(https://wtydreamt.github.io/assets/images/railss.jpg)"><div class="cover"><div class="cover-text"><div class="heading"> <a href="/posts/#memcache">memcache</a></div><p> 入门到放弃！</div></div><div id="switcher"></div></aside><main class="content-wrapper"><article class="post"><h1 class="post-title">memcache 资料!</h1><p class="post-meta"> <time datetime="2016-09-05">05-09-2016</time> &nbsp;/&nbsp; <span>redVi</span><div class="post-content"><h5 id="memcache">MemCache是什么</h5><p>MemCache的数据存放在内存中同时意味着只要MemCache重启了，数据就会消失<p>MemCache是一个自由、源码开放、高性能、分布式的分布式内存对象缓存系统，用于动态Web应用以减轻数据库的负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高了网站访问的速度。MemCaChe是一个存储键值对的HashMap，在内存中对任意的数据（比如字符串、对象等）所使用的key-value存储，数据可以来自数据库调用、API调用，或者页面渲染的结果。<p><img src="/assets/images/memcache.jpg" alt="" /><p>MemCache虽然被称为”分布式缓存”，但是MemCache本身完全不具备分布式的功能。它的分布式是通过客户端的程序实现的。<p>1、应用程序输入需要写缓存的数据<p>2、API将Key输入路由算法模块，路由算法根据Key和MemCache集群服务器列表得到一台服务器编号<p>3、由服务器编号得到MemCache及其的ip地址和端口号<p>4、API调用通信模块和指定编号的服务器通信，将数据写入该服务器，完成一次分布式缓存的写操作<p>读缓存和写缓存一样，只要使用相同的路由算法和服务器列表，只要应用程序查询的是相同的Key，MemCache客户端总是访问相同的客户端去读取数据，只要服务器中还缓存着该数据，就能保证缓存命中。<p>这种MemCache集群的方式也是从分区容错性的方面考虑的，假如Node2宕机了，那么Node2上面存储的数据都不可用了，此时由于集群中Node0和Node1还存在，下一次请求Node2中存储的Key值的时候，肯定是没有命中的，这时先从数据库中拿到要缓存的数据，然后路由算法模块根据Key值在Node0和Node1中选取一个节点，把对应的数据放进去，这样下一次就又可以走缓存了，这种集群的做法很好，但是缺点是成本比较大。<p>命 令 作 用<p>get 返回Key对应的Value值<p>add 无条件地设置一个Key值，没有就增加，有就覆盖<p>set 按照相应的Key值添加数据，如果Key已经存在则会操作失败<p>replace 按照相应的Key值替换数据，如果Key值不存在则会操作失败<p>stats 返回MemCache通用统计信息（下面有详细解读） stats items 返回各个slab中item的数目和最老的item的年龄 （最后一次访问距离现在的秒数）<p>stats slabs 返回MemCache运行期间创建的每个slab的信息（下面有详细解读）<p>version 返回当前MemCache版本号<p>flush_all 清空所有键值，但不会删除items，所以此时MemCache依旧占用内存<p>quit 关闭连接<h5 id="memcache-">memcache 的过期数据惰性删除</h5><p>清空所有键值<p>flush_all<p>注：flush并不会将items删除，只是将所有的items标记为expired，因此这时memcache依旧占用所有内存(flush 并不会把存储的数据真正的删除掉只是把这个数据的状态改为了过期失效但是它依然占用内存空间)<p>在操作系统系统中，常用的删除机制有fifo、lru删除<p>lru：least recently used 最近最少使用<p>fifo：first in，first out 最先插入，最先离开<p>原理: 当某个单元被请求时,维护一个计数器,通过计数器来判断最近谁最少被使用。<p>注: 即使某个key 是设置的永久有效期,也一样会被踢出来!<p>即–永久数据被踢现象<p>阿里2014笔试题一道：<p>memcache缓存系统采用LRU淘汰算法，假定缓存容量为4,并且初始为空，那么在顺序访问一下数据项的时候：1,5,1,3,5,2,4,1,2出现缓存直接命中的次数是？，最后缓存中即将准备淘汰的数据项是？<p>答案：3， 5<p>解答：<p>1调入内存 1<p>5调入内存 1 5<p>1调入内存 5 1（命中 1，更新次序）<p>3调入内存 5 1 3<p>5调入内存 1 3 5 （命中5）<p>2调入内存 1 3 5 2<p>4调入内存（1最久未使用，淘汰1） 3 5 2 4<p>1调入内存（3最久未使用，淘汰3） 5 2 4 1<p>2调入内存 5 4 1 2（命中2）<p>因此，直接命中次数是3,最后缓存即将准备淘汰的数据项是5 <span class="link-to-post" class="link-to-post__next"> &nbsp&nbsp&nbsp<a href="/posts/welcome-to-jekyll/">◣ 上 • jekyll github 个人博客搭建!</a> &nbsp&nbsp&nbsp &nbsp&nbsp&nbsp<a href="/posts/welcome-to-wty0905/">下 • js 调用浏览器打印页面! ◢ </a> </span></div><div class="ds-thread content-frame" data-thread-key="/posts/welcome-to-wty0901/" data-title="memcache 资料!" data-url="https://wtydreamt.github.io/posts/welcome-to-wty0901/"></div>  <script type="text/javascript"> var duoshuoQuery = {short_name:"mmm"}; (function() { var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); })(); </script> </article></main><footer class="blog-footer content-wrapper"><p>&copy; <span class="full-year"></span> TingYu Wang</footer><script src="/assets/js/scripts.js"></script>
